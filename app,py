import csv
import sqlite3
import os
from flask import Flask, render_template, request, jsonify
from werkzeug.exceptions import RequestEntityTooLarge

app = Flask(__name__)

# Set maximum file upload size to 16 MB, so system does not get overloaded
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB limit

# Path to your SQLite database file
db_path = "transactions.db"

# Function to store transactions in a file-based SQLite database
def store_transactions_in_db(file):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    cursor.execute('''
        CREATE TABLE IF NOT EXISTS transactions (
            account_name TEXT,
            card_number TEXT,
            transaction_amount REAL,
            transaction_type TEXT,
            description TEXT,
            target_card_number TEXT,
            is_valid INTEGER  -- Flag for valid/invalid transactions
        )
    ''')

    file.stream.seek(0)
    csv_reader = csv.reader(file.stream.read().decode('utf-8').splitlines())

    for row in csv_reader:
        account_name = row[0] if len(row) > 0 else "N/A"
        card_number = row[1] if len(row) > 1 else "N/A"
        transaction_type = row[3] if len(row) > 3 else "N/A"
        description = row[4] if len(row) > 4 else "N/A"
        target_card_number = row[5] if len(row) > 5 else "N/A"
        
        # Default is_valid flag
        is_valid = 1

        try:
            transaction_amount = float(row[2])
        except (ValueError, IndexError):
            transaction_amount = row[2] if len(row) > 2 else "N/A"
            is_valid = 0  # Mark as invalid without an error message
        
        cursor.execute('''
            INSERT INTO transactions (account_name, card_number, transaction_amount, transaction_type, description, target_card_number, is_valid)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        ''', (account_name, card_number, transaction_amount, transaction_type, description, target_card_number, is_valid))

    conn.commit()
    conn.close()

# Function to initialize (or recreate) the database
def init_db():
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # Create the transactions table with the is_valid column
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS transactions (
            account_name TEXT,
            card_number TEXT,
            transaction_amount REAL,
            transaction_type TEXT,
            description TEXT,
            target_card_number TEXT,
            is_valid INTEGER  -- Flag for valid/invalid transactions
        )
    ''')

    conn.commit()
    conn.close()

# Route to reset the system (clear the database)
@app.route('/reset', methods=['POST'])
def reset_system():
    # Delete the database file if it exists
    if os.path.exists(db_path):
        os.remove(db_path)

    # Recreate the database
    init_db()

    return jsonify({"message": "System reset successfully! Cleared database, cache, and tables."})

# Route to render the main page and reset the database on each refresh
@app.route('/')
def index():
    # Call reset_system() to reset the database on each page refresh
    reset_system()
    return render_template('index.html')

# Route to handle file uploads
@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return jsonify({"message": "Please upload a file."}), 400

    file = request.files['file']

    if file.filename == '':
        return jsonify({"message": "No file selected."}), 400

    if not file.filename.endswith('.csv'):
        return jsonify({"message": "Invalid file type. Please upload a CSV file."}), 400

    # Store transactions in the database
    store_transactions_in_db(file)

    # Connect to the database to query the stored transactions
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # Query to get collections (negative transaction amounts)
    cursor.execute("SELECT * FROM transactions WHERE transaction_amount < 0")
    collections = cursor.fetchall()

    # Query all transactions, separate by validity
    cursor.execute("SELECT * FROM transactions")
    all_transactions = cursor.fetchall()

    # Separate valid and invalid transactions
    valid_transactions = [t for t in all_transactions if t[6] == 1]
    bad_transactions = [t for t in all_transactions if t[6] == 0]

    conn.close()

    return jsonify({
        "message": "File processed successfully!",
        "transactions": [{"Account Name": t[0], "Card Number": t[1], "Transaction Amount": t[2], "Transaction Type": t[3], "Description": t[4], "Target Card Number": t[5], "is_valid": t[6]} for t in valid_transactions],
        "collections": [{"Account Name": c[0], "Card Number": c[1], "Transaction Amount": c[2], "Transaction Type": c[3], "Description": c[4], "Target Card Number": c[5]} for c in collections],
        "bad_transactions": [{"Account Name": b[0], "Card Number": b[1], "Transaction Amount": b[2], "Transaction Type": b[3], "Description": b[4], "Target Card Number": b[5], "is_valid": b[6]} for b in bad_transactions]
    })


@app.errorhandler(RequestEntityTooLarge)
def handle_file_size_error(e):
    return jsonify({"message": "File is too large. Maximum upload size is 16 MB."}), 413

# Initialize the database on app start
if __name__ == '__main__':
    init_db()
    app.run(debug=True)
